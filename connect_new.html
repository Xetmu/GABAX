
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Голосовой Чат с TURN</title>
</head>
<body>
  <h2>WebRTC Голосовой Чат с TURN</h2>
  <p id="status">Ожидание разрешения на микрофон...</p>

  <button id="allowMicBtn">Разрешить захват звука</button>
  <button id="startAudioBtn" style="display:none;">Включить звук</button>

  <script>
    const name = prompt("Введите имя:");
    const room = "room1";
    const signalingUrl = "wss://gregere68.fvds.ru:2222"; // WebSocket signaling
    const turnServerUrl = "turn:gregere68.fvds.ru:3478";
    const staticAuthSecret = "your_secret_key"; // static-auth-secret из Coturn

    let localStream = null;
    const peerConnections = {};
    const socket = new WebSocket(signalingUrl);
    let socketReady = false;
    let messageQueue = [];
    let useTurn = false;
    let turnCredentials = null;

    function log(msg) {
      console.log(msg);
      const st = document.getElementById("status");
      const t = new Date().toLocaleTimeString();
      st.innerHTML += `<br>[${t}] ${msg}`;
    }

    function safeSend(obj) {
      const data = JSON.stringify(obj);
      if (socketReady) {
        socket.send(data);
      } else {
        messageQueue.push(data);
      }
    }

    async function generateTurnCredentials(username, secret) {
      const unixTime = Math.floor(Date.now() / 1000) + 24 * 3600;
      const turnUsername = `${unixTime}:${username}`;

      const encoder = new TextEncoder();
      const keyData = encoder.encode(secret);
      const msgData = encoder.encode(turnUsername);

      const cryptoKey = await crypto.subtle.importKey(
        "raw",
        keyData,
        { name: "HMAC", hash: "SHA-1" },
        false,
        ["sign"]
      );

      const signature = await crypto.subtle.sign("HMAC", cryptoKey, msgData);
      const b64signature = btoa(String.fromCharCode(...new Uint8Array(signature)));

      return { username: turnUsername, password: b64signature };
    }

    socket.onopen = () => {
      socketReady = true;
      log("WebSocket открыт");
      for (const msg of messageQueue) {
        socket.send(msg);
      }
      messageQueue = [];
      safeSend({ type: "register", name });
      safeSend({ type: "join_room", room });

      if (localStream) {
        safeSend({ type: "ready", name });
      }
    };

    socket.onclose = () => log("WebSocket закрыт");
    socket.onerror = (err) => log("Ошибка WebSocket: " + err.message);

    document.getElementById('allowMicBtn').addEventListener('click', () => {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          localStream = stream;
          log("Получен локальный аудиопоток");

          document.getElementById('allowMicBtn').style.display = 'none';
          document.getElementById('startAudioBtn').style.display = 'inline-block';

          safeSend({ type: "ready", name });

          generateTurnCredentials(name, staticAuthSecret).then(creds => {
            turnCredentials = creds;
            log(`TURN credentials получены: username=${creds.username}`);
          });
        })
        .catch(err => {
          log("Ошибка доступа к микрофону: " + err.message);
          console.error(err);
        });
    });

    document.getElementById('startAudioBtn').addEventListener('click', () => {
      for (const peerName in peerConnections) {
        const audioElem = document.getElementById(`audioelem-${peerName}`);
        if (audioElem) {
          audioElem.play().catch(err => {
            console.warn('Ошибка при воспроизведении аудио:', err);
          });
        }
      }
      document.getElementById('startAudioBtn').style.display = 'none';
      log('Звук включен пользователем');
    });

    socket.onmessage = async (evt) => {
      let data;
      try {
        data = JSON.parse(evt.data);
      } catch (err) {
        console.error("Невозможно распарсить сообщение", evt.data);
        return;
      }
      const from = data.from;
      log("Получено сообщение: " + JSON.stringify(data));

      switch (data.type) {
        case "ready":
          if (from !== name && !peerConnections[from]) {
            log(`Пользователь ${from} готов — создаём offer`);
            await createOffer(from);
          }
          break;
        case "offer":
          await handleOffer(from, data.sdp);
          break;
        case "answer":
          if (peerConnections[from]) {
            await peerConnections[from].setRemoteDescription(
              new RTCSessionDescription({ type: "answer", sdp: data.sdp })
            );
          }
          break;
        case "ice-candidate":
          if (peerConnections[from]) {
            try {
              await peerConnections[from].addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
              log(`Ошибка добавления ICE-кандидата: ${e.message}`);
            }
          }
          break;
      }
    };

    function createPeerConnection(peerName) {
      if (!turnCredentials) {
        log("Ошибка: TURN credentials ещё не сгенерированы!");
        return null;
      }

      const iceServers = [
        {
          urls: turnServerUrl,
          username: turnCredentials.username,
          credential: turnCredentials.password
        },
        { urls: 'stun:stun.l.google.com:19302' }
      ];

      const pc = new RTCPeerConnection({
        iceServers,
        iceTransportPolicy: "all"
      });

      pc.onicecandidate = (evt) => {
        if (evt.candidate) {
          safeSend({
            type: "ice-candidate",
            candidate: evt.candidate,
            to: peerName,
            from: name
          });
        }
      };

      pc.oniceconnectionstatechange = () => {
        if (["failed", "disconnected"].includes(pc.iceConnectionState) && !useTurn) {
          useTurn = true;
          pc.close();
          delete peerConnections[peerName];
          setTimeout(() => createOffer(peerName), 1500);
        }
      };

      pc.ontrack = (evt) => {
        attachAudio(peerName, evt.streams[0]);
      };

      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }

      peerConnections[peerName] = pc;
      return pc;
    }

    async function createOffer(to) {
      let pc = peerConnections[to];
      if (!pc) pc = createPeerConnection(to);
      if (!pc) return;

      const offer = await pc.createOffer({ offerToReceiveAudio: true });
      await pc.setLocalDescription(offer);
      safeSend({ type: "offer", sdp: offer.sdp, to, from: name });
    }

    async function handleOffer(from, sdp) {
      let pc = peerConnections[from];
      if (!pc) pc = createPeerConnection(from);
      if (!pc) return;

      await pc.setRemoteDescription(new RTCSessionDescription({ type: "offer", sdp }));
      const answer = await pc.createAnswer({ offerToReceiveAudio: true });
      await pc.setLocalDescription(answer);
      safeSend({ type: "answer", sdp: answer.sdp, to: from, from: name });
    }

    function attachAudio(peerName, stream) {
      let container = document.getElementById(`audio-${peerName}`);
      if (!container) {
        container = document.createElement("div");
        container.id = `audio-${peerName}`;
        const label = document.createElement("div");
        label.textContent = `Пользователь: ${peerName}`;
        container.appendChild(label);

        const audio = document.createElement("audio");
        audio.id = `audioelem-${peerName}`;
        audio.autoplay = true;
        audio.controls = true;
        audio.muted = false;

        container.appendChild(audio);
        document.body.appendChild(container);
      }
      const audioElem = document.getElementById(`audioelem-${peerName}`);
      audioElem.srcObject = stream;
    }
  </script>
</body>
</html>

